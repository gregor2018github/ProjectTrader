# Plan for "Object-Process-Link" Implementation

## 1. Goal
Move from "static background tiles" for buildings to "interactive objects". This will allow:
- Proper collision detection (cannot walk on houses).
- Interaction (entering shops, click events).
- Dynamic rendering (Y-sorting so players can walk "behind" or "in front" of buildings correctly).

## 2. Industry Standard Approach
The standard way to handle this in Tiled + Pygame is:
**Tile Layers** are for the ground, terrain, and static decorations (grass, paths, cliffs).
**Object Layers** are for everything else (Houses, NPCs, Chests, Colliders).

Instead of "painting" a house tile by tile on a layer, you place a **single Map Object** that represents that house. This object has:
- Coordinate (x, y)
- Image (the sprite of the house)
- Custom Properties (e.g., `type="shop"`, `name="Bakery"`)
- Collision Box (defined in Tiled or auto-generated)

## 3. Tiled Workflow Instructions
1.  **Open `grassmap.tmx` in Tiled.**
2.  **Delete the existing "Collision" Tile Layer.** It is better to use Object-based collision.
3.  **Delete the "Houses" Tile Layers** (Upper, Middle, Lower) if you want to convert them to objects.
    *   *Alternative:* You can keep them for now, but draw "Collision Objects" over them. However, making them actual Objects is better for the long run.
4.  **Create a New Layer: "Object Layer"**. Rename it to `Buildings`.
5.  **Insert Objects**:
    *   Select the `Insert Tile` tool (shortcut `T`).
    *   Select the house image from your tileset.
    *   Click on the map to place the house as an **Object** (not a tile paint).
6.  **Add Collision Data**:
    *   Select the house object you just placed.
    *   In the "Tile Collision Editor" (if using a tile as object) OR simply draw a **Rectangle Object** over the base of the house on a separate "Colliders" object layer.
    *   *Recommended for you:* Create a layer named `Colliders`. Use the "Insert Rectangle" tool (`R`) to draw invisible boxes over the places the player shouldn't walk (house footprints, walls).

## 4. Python Implementation Plan

### Step 1: Create `MapObject` Class
Create `src/models/map_object.py`.
This class will hold:
- Image surface
- Position (rect)
- Hitbox (collision rect, usually smaller than the image, e.g., just the floor)
- Metadata (type, name)

### Step 2: Update `TMXMap` in `src/models/map.py`
Modify `TMXMap` to:
- Iterate through the `tmx_data.objects`.
- Sort them into categories (e.g., "colliders", "buildings", "trees").
- Convert `Colliders` layer objects into invisible `pygame.Rect`s for collision.
- Convert `Buildings` layer objects into `MapObject` instances.

### Step 3: Update Collision Logic
Modify `MapPlayer.can_move_to` (or `TMXMap.is_walkable`) to:
- Instead of checking tile properties, check: `if player_rect.colliderect(collider_rect): return False`.
- This is much faster and more precise.

### Step 4: Update Rendering
Modify `src/ui/layout_modules/map_view.py`.
- Ensure `MapObject`s are added to the `render_queue`.
- Existing Y-sorting logic in `map_view.py` looks good (`render_queue.sort(key=lambda obj: obj['y_sort'])`). We just need to make sure our new House objects feed into this queue.

## 5. Next Workstep (Immediate Action)
I recommend starting with **Step 4.1 (Tiled Work)** yourself to prepare the map.
Then, I can help you write the code for **Step 4.2 onwards**.

Would you like me to start creating the `MapObject` class structure now?
